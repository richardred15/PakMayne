class Drop {

    /**
     * @type {THREE.Group|THREE.Mesh}
     */
    mesh = null;
    /**
     * @type {THREE.Mesh}
     */
    sphere = null;
    /**
     * @type {THREE.Material}
     */
    material = null;
    /**
     * @type {THREE.Material}
     */
    sphereMaterial = null;
    /**
     * @type {THREE.Material}
     */
    crossMaterial = null;
    /**
     * @type {THREE.BufferGeometry}
     */
    geometry = null;

    pickedUp = false;
    myLifeTime = 10;
    myElapsedTime = 0;
    blinkSpeed = 10;
    constructor(position, color = 0xFFFF00) {

    }

    /**
     * 
     * @param {THREE.Vector3} location 
     * @returns {boolean}
     */
    isPickup(location) {
        let pickup = this.mesh.position.distanceTo(location) < game.scale;
        return pickup;
    }

    pickup(player) {
        this.pickedUp = true;
        this.onpickup(player);
    }

    update(delta) {
        this.mesh.position.setY(this.mesh.position.y + (Math.sin(this.myElapsedTime * 4) / 50));
        this.mesh.rotateY(delta);
        this.myElapsedTime += delta;
        if (this.myElapsedTime > this.myLifeTime) {
            this.pickedUp = true;
        } else if (this.myElapsedTime > (this.myLifeTime - 5)) {
            let op = Math.sin(this.myElapsedTime * this.blinkSpeed);
            this.setOpacity(op);
        }
    }

    setOpacity(op) {
        this.mesh.traverse(o => {
            if (o.isMesh) {
                o.material.opacity = op;
            }
        });
    }


    /**
     * 
     * @param {Player} player 
     */
    onpickup(player) {

    }
}
class Player {
    /**
     * Definitions
     */
    name = "";
    maxHealth = 100;
    health = 100;
    dead = false;
    ghost = false;
    /**
     * @type {THREE.Mesh}
     */
    healthBar = null;
    healthBarColor = new THREE.Color(0x00FF00);
    /**
     * @type {Weapon}
     */
    weapon = null;
    speed = 10;
    maxSpeed = 10;
    /**
     * @type {THREE.Mesh}
     */
    model = null;
    /**
     * @type {THREE.Group}
     */
    mesh = null;
    rotationVector = new THREE.Vector3();
    rotationDirection = null;
    rotationAxis = null;
    weaponRotation = null
    weaponRotationDirection = null;
    jumping = false;
    jumpVelocity = 3;

    /**
     * @type {THREE.Vector3}
     */
    targetLookLocation = null;
    damage = 0;
    colors = [];
    despawnTimer = 3;
    /**
     * Speed of rotation in radians - rads/sec
     * @type {number}
     */
    rotationSpeed = Math.PI;

    /**
     * @type {THREE.Quaternion}
     */
    targetSmoothRotation = null;

    /**
     * @type {THREE.Vector3}
     */
    targetLocation = new THREE.Vector3();
    hasTargetLocation = false;
    targetLocationCounter = new THREE.Vector3();
    /**
     * @type {THREE.Vector3}
     */
    originalLocation = null;

    /**
     * @type {THREE.Vector3}
     */
    velocity = new THREE.Vector3();
    id = "";

    /**
     * @type {Projectile}
     */
    newProjectile = null;
    /**
     * @type {Projectile[]}
     */
    deadProjectiles = [];
    size = 1;
    isBot = false;
    projectileColor = 0xffff00;
    accuracy = 0.01;
    /**
     * @type {THREE.Mesh}
     */
    frame = null;
    /**
     * @type {SoundManager}
     */
    sm = null;
    /**
     * 
     * @param {number} scale 
     * @param {THREE.Mesh} model
     */
    constructor(scale = 1, model) {
        this.mesh = new THREE.Group();
        this.mesh.position.set(0, 0, 0);
        let geometry = new THREE.BoxBufferGeometry(1 * scale, 1 * scale, 1 * scale);
        this.frame = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
            wireframe: true
        }));
        this.mesh.castShadow = true;
        this.id = Math.random().toString();
        this.scale = scale;
        this.speed *= scale;
        this.jumpVelocity *= scale;
        this.model = model;
        this.mesh.add(this.model);
        //this.mesh.add(this.frame);
        var material = new THREE.LineBasicMaterial({
            color: 0x0000ff,
            opacity: 0.1
        });

        this.healthBar = new THREE.Mesh(new THREE.PlaneBufferGeometry(this.scale, 1), new THREE.MeshBasicMaterial({
            color: this.healthBarColor,
            side: THREE.DoubleSide
        }));
        this.healthBar.position.setY(this.scale / 1.5);
        this.mesh.add(this.healthBar);

        /* var geo = new THREE.Geometry();
        geo.vertices.push(
            new THREE.Vector3(0, 0, 5 * scale),
            new THREE.Vector3(0, 0, 0)
        );

        var line = new THREE.Line(geo, material) */
        ;
        //this.mesh.add(line);
        this.sm = new SoundManager();

        this.sm.loadSound("audio/shoot.mp3");
        this.sm.loadSound("audio/pew.mp3");
        this.sm.loadSound("audio/reload.mp3");
        this.sm.loadSound("audio/laser.mp3");
        //this.sm.sounds.laser.volume = 0.2;
        this.sm.sounds.reload.volume = 0.8;
        //s.log(this.model);
        this.init();
        this.material.emissive = this.material.color;
        this.material.emissiveIntensity = 0.3;
    }

    /**
     * Functions
     */

    init() {
        this.material = new THREE.MeshPhongMaterial({
            color: 0xffff00,
            shininess: 100,
            transparent: true,
            reflectivity: 10,
            emissiveIntensity: 1,
            emissive: 0xFFFF00
        });
        this.frame.material.color = new THREE.Color(0xffff00);
        this.model.traverse((o) => {
            if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
            }
        });
        this.model.children[0].children[2].material = this.material;

        this.weapon = new Weapon({
            scale: this.scale,
            ownerid: this.id,
            projectileColor: this.projectileColor,
            accuracyMultiplier: 1,
            damage: 25
        }, this);
        this.mesh.add(this.weapon.mesh);
    }

    setGhost() {
        this.material.transparent = true;
        this.ghost = true;
    }

    update(delta) {
        this.weapon.update(delta);

        if (this.jumping) {
            if (Math.abs(this.velocity.y) <= 0.0001) {
                this.jumping = false;
            }
        }
        if (this.hasTargetLocation) {
            this.mesh.translateX(this.targetLocation.x * delta * this.speed); //position.lerp(this.targetLocation, delta);
            //this.mesh.translateY(this.targetLocation.y * delta * this.speed);

            this.mesh.translateZ(this.targetLocation.z * delta * this.speed);
            this.targetLocation.set(0, 0, 0);
            this.hasTargetLocation = false;
        }
        if (this.rotationAxis != null) {
            let dir = 1;
            switch (this.rotationDirection) {
                case DIRECTIONS.LEFT:
                    break;
                case DIRECTIONS.RIGHT:
                    dir = -1;
                    break;
                default:
                    break;
            }
            this.mesh.rotateY((dir * (this.rotationFactor / 8)) * this.rotationSpeed * delta);
            this.rotationAxis = null;
        }
        if (this.weaponRotation != null) {
            let dir = 1;
            /* switch (this.weaponRotationDirection) {
                case DIRECTIONS.UP:
                    dir = -1;
                    break;
                case DIRECTIONS.DOWN:
                    break;
                default:
                    break;
            } */
            this.weapon.mesh.rotateX((dir * (this.weaponRotation / 8)) * this.rotationSpeed * delta)
            if (Math.abs(this.weapon.mesh.rotation.x) > Math.PI / 8) this.weapon.mesh.rotateX((-dir * (this.weaponRotation / 12)) * this.rotationSpeed * delta)
            this.weaponRotation = null;

        }
        if (this.targetLookLocation != null) {
            this.turnTowardTarget(delta);

        }
        if (this.targetSmoothRotation != null) {
            let r = this.turnTowardQuaternion(this.targetSmoothRotation, delta);
            if (r) {
                this.targetSmoothRotation = null;
            }
        }
        if (this.health <= 0) {
            this.die();
        }
        if (this.healthBar) {
            this.healthBar.scale.setX(this.health / this.maxHealth);
            this.healthBar.material.color.set(this.healthBarColor.clone().lerp(new THREE.Color('red'), 1 - (this.health / this.maxHealth)));
            this.healthBar.lookAt(game.camera.position);
        }
    }

    lookAt(target) {
        this.targetLookLocation = target;
        let currentEuler = this.mesh.rotation.clone();
        this.mesh.lookAt(target);
        this.targetRotation = this.mesh.rotation.clone();
        this.mesh.rotation.set(currentEuler.x, currentEuler.y, currentEuler.z);
    }

    /**
     * 
     * @param {THREE.Vector3} target 
     */
    lookAtLevel(target) {
        this.targetLookLocation = target.clone();
        this.targetLookLocation.setY(this.mesh.position.y);
        let currentEuler = this.mesh.rotation.clone();
        this.mesh.lookAt(this.targetLookLocation);
        //this.mesh.rotation.set(currentEuler.x, currentEuler.y, this.mesh.rotation.z);
        this.targetRotation = this.mesh.rotation.clone();
        this.mesh.rotation.set(currentEuler.x, currentEuler.y, currentEuler.z);
    }

    turnTowardTarget(delta) {
        let targetRotationQuaternion = (new THREE.Quaternion()).setFromEuler(this.targetRotation);
        let r = this.turnTowardQuaternion(targetRotationQuaternion, delta);
        if (r) this.target = null;
    }

    turnTowardQuaternion(target, delta) {
        let start = (new THREE.Quaternion()).setFromEuler(this.mesh.rotation);
        start.rotateTowards(target, this.rotationSpeed * delta);
        this.mesh.rotation.setFromQuaternion(start);
        let amtCompleted = (start.clone()).dot(target);
        if (amtCompleted > 0.999) {
            return true;
        } else {
            return false;
        }
    }

    rotateSmooth(direction, movement) {
        //if (this.rotationSpeed < Math.PI * 1.5) this.rotationSpeed += 0.005
        let axis = new THREE.Vector3();
        switch (direction) {
            case DIRECTIONS.RIGHT:
                this.rotateOnAxis(new THREE.Vector3(0, 1, 0), DIRECTIONS.RIGHT, movement);
                break;
            case DIRECTIONS.LEFT:
                this.rotateOnAxis(new THREE.Vector3(0, 1, 0), DIRECTIONS.LEFT, movement);
                break;
                /* case DIRECTIONS.UP:
                    //this.rotateOnAxis(new THREE.Vector3(1, 0, 0), DIRECTIONS.UP, movement);
                    this.rotateWeapon(DIRECTIONS.UP, movement);
                    break;
                case DIRECTIONS.DOWN:
                    this.rotateWeapon(DIRECTIONS.DOWN, movement);
                    //this.rotateOnAxis(new THREE.Vector3(1, 0, 0), DIRECTIONS.DOWN, movement);
                    break; */
            default:
                break;
        }
    }

    rotateWeapon(direction, movement) {
        this.weaponRotation = movement;
        this.weaponRotationDirection = direction;
    }

    rotateOnAxis(axis, direction, movement) {
        this.rotationAxis = axis;
        this.rotationFactor = Math.abs(movement);
        this.rotationDirection = direction;
    }

    move(direction) {
        let forward = new THREE.Vector3();
        let mesh = this.mesh.clone();

        switch (direction) {
            case DIRECTIONS.UP:
                //forward.add(new THREE.Vector3(0, Math.PI / 2, 0));
                break;
            case DIRECTIONS.DOWN:
                mesh.rotateY(Math.PI);
                //forward.add(new THREE.Vector3(0, -0, 0));
                break;
            case DIRECTIONS.LEFT:
                mesh.rotateY(Math.PI / 2);
                break;
            case DIRECTIONS.RIGHT:
                mesh.rotateY(-Math.PI / 2);
                break;
            default:
                break;
        }
        mesh.getWorldDirection(forward);
        //forward.normalize();

        let speed = this.speed;
        let dir = new THREE.Vector3(speed, speed, speed);
        forward.multiply(dir);
        forward.setY(0);
        this.velocity.add(forward);
        if (Math.abs(this.velocity.x) > speed) {
            this.velocity.setX(speed * (this.velocity.x / Math.abs(this.velocity.x)))
        }
        if (Math.abs(this.velocity.z) > speed) {
            this.velocity.setZ(speed * (this.velocity.z / Math.abs(this.velocity.z)))
        }
        if (Math.abs(this.velocity.y) > speed) {
            this.velocity.setY(speed * (this.velocity.y / Math.abs(this.velocity.y)))
        }
        /* this.velocity.setX(forward.x);
        this.velocity.setZ(forward.z); */

        /* this.targetLocationCounter = this.targetLocation.clone();
        this.hasTargetLocation = true; */
    }

    jump() {
        if (!this.jumping && this.velocity.y < this.jumpVelocity) {
            this.jumping = true;
            this.velocity.y += this.jumpVelocity;
        }
    }

    hit(damage) {
        if (this.dead) return;
        this.health -= damage;
        this.damage = damage;
    }

    die() {
        this.dead = true;
        this.mesh.remove(this.healthBar);
        delete this.healthBar;
        this.weapon.die();
    }

    /**
     * 
     * @param {THREE.Vector3} rotationVector 
     */
    rotateToVector(rotationVector) {
        this.rotationVector.add(rotationVector);
    }

    toggleAuto() {
        this.weapon.autoFire = !this.weapon.autoFire;
    }

    fire() {
        if (this.dead) return false;
        this.weapon.fire();
        return true;
    }
}
class AmmoDrop extends Drop {
    constructor(position, color = 0xFF0000) {
        super(position, color);
        this.material = new THREE.MeshPhongMaterial({
            color: 0x333333,
            emissive: 0x333333,
            emissiveIntensity: 1,
            opacity: 1,
            transparent: true
        });
        this.innerMaterial = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 1,
            opacity: 1,
            transparent: true
        });
        this.mesh = game.ammoModel.clone();
        this.mesh.traverse((o) => {
            if (o.isMesh) {
                o.castShadow = game.shadowsEnabled;
                o.receiveShadow = game.shadowsEnabled;
                o.material = o.material.clone();
                /* o.material.map = o.material.map.clone(); */
                o.material.transparent = true;
            }
        });
        this.myLifeTime = 10;
        //model.children[0].material = this.innerMaterial;
        //model.children[1].material = this.material;
        this.mesh.position.set(position.x, position.y, position.z);
    }

    update(delta) {
        super.update(delta);
    }

    onpickup(player) {
        super.onpickup(player);
        player.weapon.currentAmmo = player.weapon.defaultAmmo;
        game.sm.sounds.full_ammo.play();
    }

}
class Bot extends Player {
    /**
     * Definitions
     */
    /**
     * @type {Player}
     */
    target = null;
    playerTarget = null;
    evading = false;
    evasionDirection = randInt(3, 4);
    hitCooldown = 1;
    hitCooldownCounter = 0;
    isBot = true;
    colors = [0xff0000, 0xffaaaa, 0xaaccff, 0xffaa00];
    /**
     * 
     * @param {Player} target 
     * @param {number} scale 
     * @param {THREE.Mesh} model
     */
    constructor(target, scale = 1, model) {
        super(scale, model);
        this.isBot = true;
        this.playerTarget = target;
        this.weapon.autoFireDelay = randFloat(0.5, 3);
        this.weapon.autoFire = true;
        this.accuracy = 0.05;
        this.speed = 8 * this.scale;
        this.sm.loadSound("audio/ghost_death.wav");
    }

    /**
     * Functions
     */

    init() {
        this.colors = [0xFF0000, 0xFFC0CB, 0x00FFFF, 0xFFA500];
        let color = this.colors[randInt(0, 4)];
        this.material = new THREE.MeshPhongMaterial({
            color: 0xFFC0CB,
            opacity: 0.6,
            shininess: 0.1
        });
        this.eyeMaterial = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            opacity: 0.6,
            emissive: color,
            emissiveIntensity: 5
            //shininess: 0
        });
        this.frame.material.color = this.material.color;
        //BODY
        this.model.children[0].material = this.material;
        this.model.children[1].material = this.eyeMaterial;
        this.model.children[2].material = this.material;
        this.model.children[3].material = this.eyeMaterial;
        this.model.children[4].material = this.material;
        this.projectileColor = 0xff0000;
        this.weapon = new Weapon({
            scale: this.scale,
            ownerid: this.id,
            projectileColor: this.projectileColor,
            accuracyMultiplier: 10
        }, this);
        this.model.traverse((o) => {
            if (o.isMesh) {
                o.castShadow = game.shadowsEnabled;
                o.receiveShadow = game.shadowsEnabled;
            }
        });
        this.mesh.add(this.weapon.mesh);
        this.weapon.autoFireDelay = randFloat(0.3, 0.8);

    }

    hit(damage) {
        super.hit(damage);

        if (!this.evading) {
            this.evasionDirection = randInt(3, 5);
            if (randInt(1, 25) == 5) this.evasionDirection = 5;
            this.hitCooldownCounter = 0;
            this.evading = true;
        }
    }

    setGhost() {
        super.setGhost();
        this.sm.sounds["ghost_death"].play();
        //this.material.opacity = 0.2;
        //this.eyeMaterial.opacity = 0.2;
    }

    update(delta) {
        super.update(delta);
        if (this.playerTarget.dead && !this.dead) {
            let pos = this.mesh.position;
            let closestP = null;
            let closest = Infinity;
            for (let b in game.bots) {
                let bot = game.bots[b];
                if (bot.id == this.id || bot.dead) continue;
                let d = bot.mesh.position.distanceTo(pos);
                if (d < closest) {
                    closest = d;
                    closestP = bot;
                }
            }
            if (closestP != null) {
                this.playerTarget = closestP;
            } else {
                this.material.color = new THREE.Color('blue');
                this.weapon.autoFire = false;
                this.die();
                /* setTimeout(() => {
                    window.location.reload()
                }, 3000); */
            }
        }
        if (!this.dead) {
            if (!game._paused) {
                this.lookAtLevel(this.playerTarget.mesh.position);
                let distance = this.mesh.position.distanceTo(this.playerTarget.mesh.position);
                //let y = this.mesh.position.y;
                if (distance < 9 * game.scale) {
                    this.move(DIRECTIONS.DOWN);
                } else if (distance > 11 * game.scale) {
                    this.move(DIRECTIONS.UP);
                }
                //this.mesh.position.y = y;
                if (this.evading) {
                    if (this.evasionDirection == 5) {
                        this.jump();
                        this.evading = false;
                    } else {
                        if (this.hitCooldownCounter < this.hitCooldown) {
                            this.move(this.evasionDirection);
                            this.hitCooldownCounter += delta;
                        } else this.evading = false;
                    }
                }
            }
        } else {
            this.mesh.position.setY(this.mesh.position.y + 0.2);
            if (this.material.opacity > 0 || this.eyeMaterial.opacity > 0) {
                this.material.opacity -= 0.008;
                this.eyeMaterial.opacity -= 0.008;
            }
            this.despawnTimer -= delta;
            if (this.despawnTimer <= 0) {
                game.scene.remove(this.mesh);
                delete game.bots[this.id];
            }
        }
        /* if (this.targetLookLocation != null) {
            let weaponLookLocation = this.playerTarget.mesh.position.clone();
            //if (weaponLookLocation.z - (this.scale) > this.mesh.position.z) {
            this.weapon.mesh.lookAt(weaponLookLocation);
            if (Math.abs(this.weapon.mesh.rotation.z) > 45) {
                this.weapon.mesh.rotation.set(this.mesh.rotation.x, this.mesh.rotation.y, (this.weapon.mesh.rotation.z / Math.abs(this.mesh.rotation.z) * 45));
            }
            //}
        } */
    }

    die() {
        super.die();
    }

    fire() {
        if (super.fire()) {} else {
            return false;
        }
        return true;
    }
}
class Game {
    /**
     * Definitions
     */
    CAMERAMODES = {
        FirstPerson: 1,
        ThirdPerson: 2
    }
    scale = 5;
    /**
     * @type {Worker}
     */
    worker = null;
    gameInterval = null;
    /**
     * @type {THREE.Clock}
     */
    clock = new THREE.Clock();
    playClock = new THREE.Clock();
    deathTime = 0;
    physicsClock = new THREE.Clock();
    /**
     * @type {UserInput}
     */
    input = null;
    ready = false;
    next = true;
    /**
     * @type {Player}
     */
    player = null;
    /**
     * @type {Player[]}
     */
    players = [];
    /**
     * @type {Bot[]}
     */
    bots = [];
    /**
     * @type {Drop[]}
     */
    drops = [];
    /**
     * @type {World}
     */
    map = null;
    /**
     * @type {THREE.Scene}
     */
    scene = null;
    _paused = true;
    renderOnce = true;
    focused = false;
    lost = false;
    gameOver = false;
    frameRate = 30;
    frameCount = 0;
    /**
     * @type {THREE.Mesh}
     */
    playerModel = null;
    botModel = null;
    /**
     * @type {THREE.Mesh}
     */
    crossModel = null;
    ammoModel = null;
    ammoModelLoaded = false;
    crossModelLoaded = false;
    playerModelLoaded = false;
    botModelLoaded = false;
    /**
     * @type {THREE.Camera}
     */
    camera = null;
    cameraOffset = {
        x: 0,
        y: 3,
        z: -5
    }
    cameraMode = this.CAMERAMODES.ThirdPerson;
    /**
     * @type {THREE.Renderer}
     */
    renderer = null;
    totalProjectiles = 0;
    totalEProjectiles = 0;
    diagnosticsElement = document.getElementById("diagnostics");
    fpsDisplay = document.getElementById("framerate");
    physicsFPSDisplay = document.getElementById("physicsFrameRate");
    objectCountDisplay = document.getElementById("objectCount");
    eObjectCountDisplay = document.getElementById("engineObjects");

    healthDisplay = document.getElementById("health");
    botsLeftDisplay = document.getElementById("bots_left");
    timeSurvivedDisplay = document.getElementById("time_survived");
    roundDisplay = document.getElementById("round");
    qualitySelector = document.getElementById("quality_selector");
    ammoDisplay = document.getElementById("ammo");
    pausedDisplay = document.getElementById("paused");
    menuDisplay = document.getElementById("menu");

    playButton = document.getElementById("play");

    botCount = 2;
    currentBotCount = 0;
    botsAlive = 0;
    respawnTime = 5;
    respawnCounter = 0;
    round = 0;
    customSize = null;
    healthModel = null;

    shadowsEnabled = false;
    shadowMapSize = 512;
    screenSize = {
        width: window.innerWidth,
        height: window.innerHeight
    }
    antialias = true;
    resolutionScale = 1;

    /**
     * @type {SoundManager}
     */
    sm = null;

    constructor() {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 10 * this.scale, 30 * this.scale);
        this.camera.lookAt(0, 10, 0);
        this.setupRenderer();

        this.map = new World();
        this.scene.add(this.map.mesh);
        // Create a directional light
        const light = new THREE.HemisphereLight(0xffffff, 0.75);

        //light.castShadow = true;
        console.log("Game loaded");
        // move the light back and up a bit
        light.position.set(0, 20, 5);
        // remember to add the light to the scene
        this.scene.add(light);
        //this.scene.add(this.dirLight);

        var deltaX = 10;
        var deltaY = 5;
        this.cameraAngle = Math.atan2(deltaY, deltaX);
        // @ts-ignore
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        /* const loader = new THREE.CubeTextureLoader();
        const t = loader.load([
            'textures/bkg1_right.png',
            'textures/bkg1_left.png',
            'textures/bkg1_top.png',
            'textures/bkg1_bot.png',
            'textures/bkg1_front.png',
            'textures/bkg1_back.png',
        ]);
        this.scene.background = t; */

        this.sm = new SoundManager();

        this.sm.loadSound("audio/shoot.mp3");
        this.sm.loadSound("audio/pickup.mp3");
        this.sm.loadSound("audio/full_ammo.mp3", 1);
        this.sm.loadSound("audio/max_health.mp3", 1);
    }

    /**
     * Functions
     */

    toggleCameraMode() {
        if (this.cameraMode == this.CAMERAMODES.ThirdPerson) {
            this.cameraOffset = {
                x: 0,
                y: 0,
                z: 2
            }
            this.cameraMode = this.CAMERAMODES.FirstPerson;
        } else if (this.cameraMode == this.CAMERAMODES.FirstPerson) {
            this.cameraOffset = {
                x: 0,
                y: 3,
                z: -5
            }
            this.cameraMode = this.CAMERAMODES.ThirdPerson;
        }
    }

    setupRenderer() {
        let quality = this.getQuality();
        let qi = 2;
        switch (quality) {
            case "ultra":
                this.shadowsEnabled = true;
                this.shadowMapSize = 4069;
                this.antialias = true;
                qi = 0;
                break;
            case "high":
                this.resolutionScale = 1;
                this.shadowsEnabled = true;
                this.antialias = true;
                qi = 1;
                break;
            case "medium":
                this.resolutionScale = 0.6;
                this.shadowsEnabled = false;
                this.antialias = true;
                qi = 2;
                break;
            case "low":
                this.resolutionScale = 0.5;
                this.shadowsEnabled = false;
                this.antialias = false;
                qi = 3;
                break;
            case "ultra-low":
                this.resolutionScale = 0.5;
                this.shadowsEnabled = false;
                this.antialias = false;
                qi = 4;
                this.screenSize = {
                    width: 1280,
                    height: 720
                }
                break;
            default:
                break;
        }
        this.qualitySelector.children[qi].style.backgroundColor = "#444";
        let reload = false;
        if (this.renderer != null) reload = true;
        else {
            this.renderer = new THREE.WebGLRenderer({
                antialias: this.antialias
            });
        }
        this.renderer.setClearColor(0x333333);
        this.renderer.shadowMap.enabled = this.shadowsEnabled;
        this.renderer.setSize(this.screenSize.width, this.screenSize.height);
        this.renderer.setPixelRatio(this.resolutionScale);
        if (reload) {
            let go = confirm("Restart required to apply all settings. Restart Now?");
            if (go) {
                window.location.reload();
            }
        }
    }

    getQuality() {
        let set = localStorage.getItem("quality");
        if (set == "custom") {
            let opts = localStorage.getItem("quality-options");
            if (opts) {
                let obj = JSON.parse(opts);
                this.shadowsEnabled = obj.shadowsEnabled;
                this.resolutionScale = obj.resolutionScale;
                if (obj.screenSize.width != -1) this.screenSize.width = obj.screenSize.width;
                if (obj.screenSize.height != -1) this.screenSize.height = obj.screenSize.height;
                this.antialias = obj.antialias;
            }
        } else {
            if (set == null) {
                set = "medium";
                localStorage.setItem("quality", "medium");
            }
            return set;
        }
    }

    setQuality(quality) {
        localStorage.setItem("quality", quality);
        this.setupRenderer();
    }

    setShadows(state) {
        this.renderer.shadowMap.enabled = state;
    }

    lowRes(state) {
        if (state) {
            this.renderer.setPixelRatio(0.5);
            this.customSize = {
                w: 1280,
                h: 720
            }
        } else {
            this.renderer.setPixelRatio(1);
            this.customSize = null;
        }
        this.resize();
    }

    resize() {
        if (this.customSize == null) {
            game.renderer.setSize(window.innerWidth, window.innerHeight);
        } else {
            game.renderer.setSize(Math.min(this.customSize.w, window.innerWidth), Math.min(this.customSize.h, window.innerHeight));
        }
    }

    initializePhysics() {
        let players = [];
        for (let p in this.players) {
            let player = this.players[p];
            let pData = {
                id: player.id,
                position: this.vectorQuatToObject(player.mesh.position),
                quaternion: this.vectorQuatToObject(player.mesh.quaternion),
                velocity: this.vectorQuatToObject(player.velocity)
            }

            players.push(pData);
        }
        /* let bots = [];
                for (let b in this.bots) {
                    let bot = this.bots[b];
                    let bData = {
                        id: bot.id,
                        position: this.vectorQuatToObject(bot.mesh.position),
                        quaternion: this.vectorQuatToObject(bot.mesh.quaternion),
                        velocity: this.vectorQuatToObject(bot.velocity)
                    }
        
                    bots.push(bData);
                } */
        let message = {
            type: "init",
            players: players,
            /* bots: bots, */
            scale: this.scale
        }
        this.worker.postMessage(message);
    }

    /**
     * 
     * @param {THREE.Vector3|THREE.Quaternion} vectorQuat 
     */
    vectorQuatToObject(vectorQuat) {
        let arr = vectorQuat.toArray();
        let obj = {};
        if (arr.length == 4) {
            obj.w = arr[3];
        }
        obj.x = arr[0];
        obj.y = arr[1];
        obj.z = arr[2];
        return obj;
    }

    /**
     * 
     * @param {number} delta 
     */
    // @ts-ignore
    updateCamera(delta) {
        if (!this.player.dead) {
            var relativeCameraOffset = new THREE.Vector3(this.cameraOffset.x, this.cameraOffset.y * this.scale, this.cameraOffset.z * this.scale);
            var cameraOffset = relativeCameraOffset.applyMatrix4(this.player.mesh.matrixWorld);
            this.camera.position.lerp(cameraOffset, 1);
            this.camera.lookAt(this.player.mesh.position);
            if (this.cameraMode == this.CAMERAMODES.FirstPerson) this.camera.rotateY(Math.PI);
            //this.dirLight.lookAt(this.player.mesh.position);
        } else {
            this.camera.position.lerp(new THREE.Vector3(0, 120, 0), 0.05);
            this.camera.lookAt(new THREE.Vector3(0, -10, 0));
            this.camera.rotation.set(-Math.PI / 2, 0, -Math.PI / 2);
        }
    }

    lockChangeAlert() {
        if (document.pointerLockElement === this.renderer.domElement) {
            this.focused = true;
            this.resume();
            //statusElement.innerHTML = "";
            // Do something useful in response
        } else {
            this.focused = false;
            //this._paused = true;
            if (!this.player.dead) this.pause();
            //if (!player.remove) statusElement.innerHTML = "_PAUSED";
            // Do something useful in response
        }
    }

    load() {
        let gltfLoader = new THREE.GLTFLoader();

        this.playerModel = null;
        this.botModel = null;
        // @ts-ignore
        gltfLoader.load("models/Bro2.glb",
            function (gltf) {
                /**
                 * @type {THREE.Mesh}
                 */
                let model = gltf.scene.children[0];
                model.rotateY(Math.PI);
                model.scale.set(10, 10, 10);
                var box = new THREE.Box3().setFromObject(model);
                var center = new THREE.Vector3();
                box.getCenter(center);
                model.position.sub(center);
                game.playerModel = model;
                game.playerModelLoaded = true;
            },
            // @ts-ignore
            function (progress) {},
            function (err) {
                console.log(err);
            });

        let objLoader = new THREE.OBJLoader();

        // @ts-ignore
        objLoader.load("models/GHOST.obj",
            function (obj) {
                console.log(obj);
                /**
                 * @type {THREE.Mesh}
                 */
                let model = obj;
                //model.rotateY(Math.PI);

                model.scale.set(2, game.scale / 2.71, game.scale / 2.04);
                var box = new THREE.Box3().setFromObject(model);
                var center = new THREE.Vector3();
                box.getCenter(center);
                model.position.sub(center);
                game.botModel = model;
                game.botModelLoaded = true;
            },
            // @ts-ignore
            function (progress) {},
            function (err) {
                console.log(err);
            });

        /**
         * @type {THREE.MTLLoader}
         */
        let mtl = new THREE.MTLLoader();

        mtl.load("models/bullet.mtl",
            /**
             * 
             * @param {THREE.MTLLoader.MaterialCreator} matCreator 
             */
            function (matCreator) {
                matCreator.preload();
                //console.log(matCreator.materials["Material.013"].emmisive = new THREE.Color(255, 255, 255));
                //console.log(matCreator.materials["Material.001"].color.setRGB(1, 0.5, 0));
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(matCreator);
                objLoader.load("models/bullet.obj",
                    function (obj) {
                        console.log(obj);
                        /**
                         * @type {THREE.Mesh}
                         */
                        let model = obj;
                        //model.rotateY(Math.PI);
                        model.scale.setScalar(0.5);

                        /* model.scale.set(2, game.scale / 2.71, game.scale / 2.04);*/
                        var box = new THREE.Box3().setFromObject(model);
                        var center = new THREE.Vector3();
                        box.getCenter(center);
                        model.position.sub(center);
                        game.ammoModel = model;
                        game.ammoModelLoaded = true;
                        /* model.position.setY(1);
                        model.scale.setScalar(2);
                        game.scene.add(model.clone()); */
                    },
                    // @ts-ignore
                    function (progress) {},
                    function (err) {
                        console.log(err);
                    });
            });
        objLoader.load("models/cross.obj",
            function (obj) {
                obj.scale.setScalar(0.3);
                game.crossModel = obj;
                game.crossModelLoaded = true;
            },
            // @ts-ignore
            function (progress) {},
            function (err) {
                console.log(err);
            });



    }

    init() {
        document.body.appendChild(this.renderer.domElement);
        let self = this;
        document.addEventListener('pointerlockchange', function () {
            self.lockChangeAlert()
        }, false);

        this.player = new Player(this.scale, this.playerModel.clone());
        this.player.weapon.addFlashlight();
        //this.player.health = 500;
        //this.player.maxHealth = 500;
        this.player.mesh.position.set(0, 10, 0);
        this.player.mesh.castShadow = true;
        this.players[this.player.id] = this.player;

        this.input = new UserInput(this.player);


        for (let p in this.players) {
            this.scene.add(this.players[p].mesh);
        }

        /* for (let p in this.bots) {
            this.scene.add(this.bots[p].mesh);
        } */
        this.worker = new Worker('worker.js');
        this.worker.onmessage = this.workerMessage;
        this.initializePhysics();
        this.newRound();
        this.playClock.start();
    }

    spawnBots() {
        for (let i = 0; i < this.botCount; i++) {
            let p = new Bot(this.player, this.scale, this.botModel.clone());
            if (this.player.dead) p.weapon.damage = 50;
            let pos = new THREE.Vector3(randInt(-10 * this.scale, 10 * this.scale), -this.scale, randInt(-10 * this.scale, 10 * this.scale));
            while (pos.distanceTo(this.player.mesh.position) < 5 * this.scale) {
                pos = new THREE.Vector3(randInt(-10 * this.scale, 10 * this.scale), -this.scale, randInt(-10 * this.scale, 10 * this.scale));
            }
            p.mesh.position.set(pos.x, pos.y, pos.z);
            this.bots[p.id] = p;
            this.scene.add(p.mesh);
            let bData = {
                id: p.id,
                position: this.vectorQuatToObject(p.mesh.position),
                quaternion: this.vectorQuatToObject(p.mesh.quaternion),
                velocity: this.vectorQuatToObject(p.velocity)
            }
            this.worker.postMessage({
                type: 'init',
                bots: [bData]
            })
        }
    }

    nextRound() {
        this.spawnBots()
        if (this.botCount < 20) {
            if (this.round % 5 == 0) this.botCount++;
        }
        if (!this.player.dead) {
            this.round++;
            //if (this.botCount > 20) this.botCount = 20;
        }
    }

    newRound() {
        for (let b in this.bots) this.bots[b].die();
        this.nextRound();
    }

    start() {
        //this.gameTimeout = setTimeout(this.render, 0);        
    }

    pause() {
        this._paused = true;
        this.playClock.stop();
        this.openMenu();
        this.playButton.innerHTML = "RESUME";
        //this.pausedDisplay.style.bottom = "0";
    }

    resume() {
        if (this._paused) this.playClock.start();
        this._paused = false;
        this.closeMenu();
        this.playButton.innerHTML = "PLAY";
        ///this.pausedDisplay.style.bottom = "100vh";
        this.renderer.domElement.requestPointerLock();
    }

    update(delta) {
        if (this.input.isKeyDown('W')) {
            this.player.move(DIRECTIONS.UP);
        }
        if (this.input.isKeyDown('A')) {
            this.player.move(DIRECTIONS.LEFT);
        }
        if (this.input.isKeyDown('S')) {
            this.player.move(DIRECTIONS.DOWN);
        }
        if (this.input.isKeyDown('D')) {
            this.player.move(DIRECTIONS.RIGHT);
        }
        if (this.input.isKeyDown(' ')) {
            this.player.jump();
        }
        if (this.input.isKeyDown('G')) {
            if (!game.player.weapon.autoFire) {
                setInterval(function () {
                    game.player.rotateSmooth(DIRECTIONS.RIGHT, 1)
                }, 1000 / 60);
                this.player.toggleAuto();
            }
        }
        if (this.input.isKeyDown('R')) {
            this.player.weapon.reload();
        }
        if (this.input.isKeyDown('P')) {
            game.pause();
        }
        if (this.input.keyPressed('C')) {
            game.toggleCameraMode();
        }
        let mouseDelta = this.input.mouseDelta();
        if (mouseDelta.x < 0) {
            this.player.rotateSmooth(DIRECTIONS.LEFT, mouseDelta.x / 6);
        }
        if (mouseDelta.x > 0) {
            this.player.rotateSmooth(DIRECTIONS.RIGHT, mouseDelta.x / 6);
        }

        if (mouseDelta.y < 0) {
            this.player.rotateSmooth(DIRECTIONS.UP, mouseDelta.y / 6);
        }
        if (mouseDelta.y > 0) {
            this.player.rotateSmooth(DIRECTIONS.DOWN, mouseDelta.y / 6);
        }
        if (this.input.isMouseDown(0)) {
            this.player.fire();
        }
        for (let i = this.drops.length - 1; i >= 0; i--) {
            let drop = this.drops[i];
            drop.update(delta);
            if (drop.pickedUp) {
                this.scene.remove(drop.mesh);
                this.drops.splice(i, 1);
            }
        }
        for (let p in this.players) {
            let player = this.players[p];

            if (!this._paused) player.update(delta);
            if (player.dead && !player.ghost) {
                for (let b in this.bots) this.bots[b].weapon.damage = 50;
                if (player.id == game.player.id) {
                    game.deathTime = game.playClock.getElapsedTime();
                }
                this.worker.postMessage({
                    type: "killPlayer",
                    id: player.id
                });
                player.setGhost();
            } else if (!player.dead && this.drops.length > 0) {
                for (let i = this.drops.length - 1; i >= 0; i--) {
                    let drop = this.drops[i];
                    if (drop) {
                        if (drop.isPickup(player.mesh.position)) {
                            drop.pickup(player);
                            //this.sm.sounds.pickup.play();
                        }
                    }
                }
            }
            /* if (player.newProjectile != null) {
                let vel = player.newProjectile.velocity;
                //player.newProjectile.mesh.rotateY(-Math.PI / 2);
                this.worker.postMessage({
                    type: "projectile",
                    id: player.newProjectile.id,
                    ownerid: player.id,
                    position: this.vectorQuatToObject(player.newProjectile.mesh.position),
                    quaternion: this.vectorQuatToObject(player.newProjectile.mesh.quaternion),
                    velocity: vel,
                    damage: player.newProjectile.damage
                });
                player.newProjectile = null;
            }
            if (player.deadProjectiles.length > 0) {
                for (let proj of player.deadProjectiles) {
                    this.worker.postMessage({
                        type: "killProjectile",
                        id: proj.id,
                        ownerid: player.id
                    });
                }
                player.deadProjectiles = [];
            } */
        }
        this.botsAlive = 0;
        this.currentBotCount = 0;
        for (let b in this.bots) {
            let bot = this.bots[b];
            this.currentBotCount++;
            if (!this._paused) bot.update(delta);
            if (bot.dead && !bot.ghost) {
                this.worker.postMessage({
                    type: "killBot",
                    id: bot.id
                });
                bot.setGhost();
                if (randInt(0, 100) < 50) {
                    //let type = 0xFFFF00;
                    let type = randInt(0, 10) < 5 ? 0xFFFF00 : 0xFF0000
                    let drop; // = new Drop(bot.mesh.position, type);
                    if (type == 0xFF0000) {
                        drop = new HealthDrop(bot.mesh.position, type);
                    } else {
                        drop = new AmmoDrop(bot.mesh.position, type);
                    }
                    this.scene.add(drop.mesh);
                    this.drops.push(drop);
                }
            } else if (!bot.dead) {
                this.botsAlive++;
                if (!this.map.inMap(bot.mesh.position)) {
                    bot.mesh.position.set(0, 10, 0);
                }
            }
            /* if (bot.newProjectile != null) {
                let vel = bot.newProjectile.velocity;
                //bot.newProjectile.mesh.rotateY(-Math.PI / 2);
                this.worker.postMessage({
                    type: "projectile",
                    id: bot.newProjectile.id,
                    ownerid: bot.id,
                    position: this.vectorQuatToObject(bot.newProjectile.mesh.position),
                    quaternion: this.vectorQuatToObject(bot.newProjectile.mesh.quaternion),
                    velocity: vel,
                    damage: bot.newProjectile.damage
                });
                bot.newProjectile = null;
            }
            if (bot.deadProjectiles.length > 0) {
                for (let proj of bot.deadProjectiles) {
                    this.worker.postMessage({
                        type: "killProjectile",
                        id: proj.id,
                        ownerid: bot.id
                    });
                }
                bot.deadProjectiles = [];
            } */
        }
        //this.controls.update();
        //this.physicsClock.getDelta();
        this.updateCamera(delta);
        if (this.currentBotCount == 0) {
            if (this.respawnCounter < this.respawnTime) {
                this.respawnCounter += delta;
            } else {
                this.newRound();
            }
        }

        this.input.update();
    }

    workerMessage(e) {
        let data = e.data;

        if (data.type == "update") {
            let time = game.physicsClock.getDelta();
            game.physicsFPSDisplay.innerHTML = `Physics: ${(1/time).toFixed(2)} fps`;

            for (let player of data.players) {
                if (game.players[player.id] != undefined) {
                    let p = game.players[player.id];
                    /* if (player.position.y > 15) {
                        if (player.velocity.y > 0) player.velocity.y = 0;
                        player.position.y = 15;
                    } */
                    p.mesh.position.set(player.position.x, player.position.y, player.position.z);
                    //p.mesh.quaternion.set(player.quaternion.x, player.quaternion.y, player.quaternion.z, player.quaternion.w);
                    //let newRot = p.mesh.rotation.toVector3().multiply(new THREE.Vector3(0, 1, 0));
                    //p.mesh.rotation.setFromVector3(newRot);
                    p.velocity.set(player.velocity.x, player.velocity.y, player.velocity.z);

                    /* if (data.projectiles[player.id] != undefined) {
                            for (let pr of data.projectiles[player.id]) {
                                let p = player.projectiles[pr.id];
    
                                p.mesh.position.set(pr.position.x, pr.position.y, pr.position.z);
                                p.mesh.quaternion.set(pr.quaternion.x, pr.quaternion.y, pr.quaternion.z, pr.quaternion.w);
                                //p.mesh.rotation.set(0, p.mesh.rotation.y, 0);
                                p.velocity.set(pr.velocity.x, pr.velocity.y, pr.velocity.z);
                            }
                        } */
                }
            }

            for (let bot of data.bots) {
                if (game.bots[bot.id] != undefined) {
                    let p = game.bots[bot.id];
                    if (bot.position.y > 15) bot.position.y = 15;
                    p.mesh.position.set(bot.position.x, bot.position.y, bot.position.z);
                    p.mesh.quaternion.set(bot.quaternion.x, bot.quaternion.y, bot.quaternion.z, bot.quaternion.w);
                    p.velocity.set(bot.velocity.x, bot.velocity.y, bot.velocity.z);

                    /* if (data.projectiles[bot.id] != undefined) {
                            for (let pr of data.projectiles[bot.id]) {
                                let b = bot.projectiles[pr.id];
    
                                b.mesh.position.set(pr.position.x, pr.position.y, pr.position.z);
                                b.mesh.quaternion.set(pr.quaternion.x, pr.quaternion.y, pr.quaternion.z, pr.quaternion.w);
                                //p.mesh.rotation.set(0, p.mesh.rotation.y, 0);
                                b.velocity.set(pr.velocity.x, pr.velocity.y, pr.velocity.z);
                            }
                        } */
                }
            }
            game.totalEProjectiles = 0;
            for (let proj of data.projectiles) {
                let p = game.players[proj.ownerid];
                if (p == undefined) p = game.bots[proj.ownerid];
                //console.log(proj.ownerid);
                if (p != undefined) {
                    let projectile = p.weapon.projectiles[proj.id];
                    if (projectile != undefined) {
                        if (proj.dead) projectile.die()
                        else {
                            game.totalEProjectiles++;
                            if (projectile != undefined) {
                                projectile.mesh.position.set(proj.position.x, proj.position.y, proj.position.z);
                                projectile.mesh.quaternion.set(proj.quaternion.x, proj.quaternion.y, proj.quaternion.z, proj.quaternion.w);
                            }
                        }
                    }
                }
            }
            this.next = true;
        } else if (data.type == "hit") {
            let player = game.players[data.id] || game.bots[data.id];
            if (player != undefined) {
                player.hit(data.damage);
                let owner = game.players[data.ownerid] || game.bots[data.ownerid];
                if (owner.weapon.projectiles[data.projectileid]) owner.weapon.projectiles[data.projectileid].die();
            }
        }

        //console.log(data.projectiles);

        /* for (let projectile of data.projectiles) {
                    let player = game.players[projectile.ownerid];
                    let pr = player.projectiles[projectile.id];
        
        
                } */

        //console.log(data);

        /* game.player.mesh.position.set(data.position.x, data.position.y, data.position.z);
                game.player.mesh.rotation.setFromQuaternion(new THREE.Quaternion(data.rotation.x, data.rotation.y, data.rotation.z, data.rotation.w));
                game.player.velocity.set(data.velocity.x, data.velocity.y, data.velocity.z); */
    }

    simulate(delta) {
        let pData = [];
        for (let id in this.players) {
            let player = this.players[id];
            if (player.dead) continue;
            pData.push({
                id: id,
                position: this.vectorQuatToObject(player.mesh.position),
                quaternion: this.vectorQuatToObject(player.mesh.quaternion),
                velocity: this.vectorQuatToObject(player.velocity)
            });
        }
        let bData = [];
        for (let id in this.bots) {
            let bot = this.bots[id];
            if (bot.dead) continue;
            bData.push({
                id: id,
                position: this.vectorQuatToObject(bot.mesh.position),
                quaternion: this.vectorQuatToObject(bot.mesh.quaternion),
                velocity: this.vectorQuatToObject(bot.velocity)
            });
        }

        let data = {
            type: "simulate",
            delta: delta,
            players: pData,
            bots: bData
        };


        // @ts-ignore
        this.worker.postMessage(data);

        /* let pos = game.player.mesh.position.toArray();
        let rot = (new THREE.Quaternion()).setFromEuler(game.player.mesh.rotation).toArray();
        let vel = game.player.velocity.toArray();
        game.worker.postMessage({
            delta: delta,
            player: {
                position: {
                    x: pos[0],
                    y: pos[1],
                    z: pos[2]
                },
                rotation: {
                    x: rot[0],
                    y: rot[1],
                    z: rot[2],
                    w: rot[3]
                },
                velocity: {
                    x: vel[0],
                    y: vel[1],
                    z: vel[2]
                }
            }
        }); */
    }

    render() {
        if (!this.ready && this.next) return;
        if (this._paused && !this.renderOnce) return;
        this.renderOnce = false;
        this.next = false;
        let delta = this.clock.getDelta();
        this.update(delta);

        this.simulate(delta);
        this.renderer.render(this.scene, this.camera);
        this.fpsDisplay.innerHTML = `Render: ${(1/delta).toFixed(2)} fps`;
        this.objectCountDisplay.innerHTML = `Projectiles: ${this.totalProjectiles} | Physics: ${this.totalEProjectiles}`;
        this.healthDisplay.innerHTML = `HP: ${this.player.health}`;
        this.roundDisplay.innerHTML = `Round: ${this.round}`;
        this.botsLeftDisplay.innerHTML = `Bots Left: ${this.botsAlive}`;
        let fullSeconds = Math.floor(this.player.dead ? this.deathTime : this.playClock.getElapsedTime());
        let seconds = ("0" + (fullSeconds % 60)).slice(-2);
        let minutes = ("0" + Math.floor(fullSeconds / 60)).slice(-2);
        this.timeSurvivedDisplay.innerHTML = `Time Survived: ${minutes}:${seconds}`;
        this.ammoDisplay.innerHTML = `${game.player.weapon.magazine}/${game.player.weapon.currentAmmo}`;
        this.frameCount++;
    }

    openMenu() {
        this.menuDisplay.style.bottom = "0px";
    }

    closeMenu() {
        this.menuDisplay.style.bottom = "100vh";
    }
}
class HealthDrop extends Drop {
    constructor(position, color = 0xFFFF00) {
        super(position, color);
        this.material = new THREE.MeshPhongMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 1,
            wireframe: false,
            transparent: true
        });
        this.mesh = game.crossModel.clone();

        this.mesh.traverse((o) => {
            if (o.isMesh) {
                o.castShadow = game.shadowsEnabled;
                o.receiveShadow = game.shadowsEnabled;
                o.material = this.material
            }
        });
        this.mesh.position.set(position.x, position.y, position.z);
    }

    onpickup(player) {
        super.onpickup(player);
        player.health = player.maxHealth;
        game.sm.sounds.max_health.play();
    }
}
let DIRECTIONS = {
    UP: 1,
    DOWN: 2,
    LEFT: 3,
    RIGHT: 4
}

let MOUSE_DIRECTIONS = {
    x: 1,
    y: 0
}

class UserInput {
    /**
     * Definitions
     */

    mouseX = 0;
    mouseY = 0;

    mouseXDelta = 0;
    mouseYDelta = 0;

    lastXDelta = 0;
    lastYDelta = 0;

    held = {};
    pressed = {};

    mousePressed = [false, false, false];


    /**
     * @type {Player}
     */
    player = null;
    /** 
     * @param {Player} player 
     */
    constructor(player) {
        this.player = player;
    }

    keyPressed(key) {
        return this.pressed[key] == undefined ? false : this.pressed[key];
    }

    isKeyDown(key) {
        return this.held[key] == undefined ? false : this.held[key];
    }

    update() {
        this.pressed = {};
    }

    /**
     * 
     * @param {KeyboardEvent} e 
     */
    onkeydown(e) {
        this.held[e.key.toUpperCase()] = true;
        this.pressed[e.key.toUpperCase()] = true;
    }

    onkeyup(e) {
        this.held[e.key.toUpperCase()] = false;
    }

    mouseDelta() {
        let x = this.mouseXDelta;
        this.lastXDelta = x;
        this.mouseXDelta = 0;
        let y = this.mouseYDelta;
        this.lastYDelta = y;
        this.mouseYDelta = 0;

        return {
            x: x,
            y: y
        };
    }

    isMouseDown(button) {
        return this.mousePressed[button];
    }

    onmousedown(e) {
        this.mousePressed[e.button] = true;
    }

    onmouseup(e) {
        this.mousePressed[e.button] = false;
    }

    /**
     * 
     * @param {MouseEvent} e 
     */
    onmousemove(e) {
        //return;
        this.mouseXDelta += e.movementX;
        this.mouseYDelta += e.movementY;
        this.mouseX = e.clientX;
        this.mouseY = e.clientY;
        /* if (e.movementX < 0) {
            this.player.rotateSmooth(DIRECTIONS.LEFT, e.movementX);
        }
        if (e.movementX > 0) {
            this.player.rotateSmooth(DIRECTIONS.RIGHT, e.movementX);
        } */
    }
}
class World {
    /**
     * Definitions
     */
    scale = new THREE.Vector3();
    size = {
        x: 200,
        z: 200
    }
    halfExtents = {
        x: this.size.x / 2,
        z: this.size.z / 2
    }
    /**
     * @type {THREE.Group}
     */
    mesh = null;

    walls = [];
    wallInfo = [{
            position: [0, -4.5, -100],
            size: [200, 20, 10]
        },
        {
            position: [-100, -4.5, 0],
            size: [10, 20, 200]
        },
        {
            position: [100, -4.5, 0],
            size: [10, 20, 200]
        },
        {
            position: [0, -4.5, 100],
            size: [200, 20, 10]
        }
        /* ,
                {
                    position: [0, -4.5, 0],
                    size: [100, 10, 10]
                } */
    ]

    constructor(_scale) {
        if (_scale) this.scale = _scale;
        this.mesh = new THREE.Group();
        this.floor = new THREE.Mesh(new THREE.BoxBufferGeometry(200, 1, 200), new THREE.MeshPhongMaterial({
            color: 0x333333,
            /* wireframe: true, */
            /* emissive: 0x021CA4,
            emissiveIntensity: 0.1 */
        }));
        for (let info of this.wallInfo) {
            let wall = new THREE.Mesh(new THREE.BoxBufferGeometry(info.size[0], info.size[1], info.size[2]), new THREE.MeshPhongMaterial({
                color: 0xaa5555,
                /* wireframe: true, */
                emissive: 0x021CA4,
                emissiveIntensity: 0.2
            }));
            wall.receiveShadow = true;
            wall.position.set(info.position[0], info.position[1], info.position[2]);
            this.mesh.add(wall);
        }
        this.floor.receiveShadow = true;
        this.floor.position.set(0, -10, 0);
        this.mesh.add(this.floor);
        this.dirLight = new THREE.DirectionalLight(0x021CA4, 2);
        this.dirLight.position.set(0, -1, 0);
        /* this.dirLight.castShadow = game.shadowsEnabled;
        this.dirLight.shadow.mapSize.width = game.shadowMapSize; // default is 512
        this.dirLight.shadow.mapSize.height = game.shadowMapSize; // default is 512 */
        //this.mesh.add(this.dirLight);
    }

    /**
     * Functions
     */

    inMap(location) {
        return (Math.abs(location.x) < this.halfExtents.x && Math.abs(location.z) < this.halfExtents.z);
    }
}
class Network {
    /**
     * Definitions
     */

    constructor() {

    }

    /**
     * Functions
     */

    connect() {

    }

    disconnect() {

    }

    emit() {

    }
}
class Projectile {
    /**
     * Definitions
     */
    damage = 25;
    /**
     * @type {THREE.Group}
     */
    mesh = null;
    /**
     * @type {THREE.BufferGeometry}
     */
    geometry = null;
    /**
     * @type {THREE.Material}
     */
    material = null;
    materialColor = 0xff0000;
    /**
     * @type {THREE.Mesh}
     */
    body = null;
    /**
     * @type {THREE.Light}
     */
    light = null;
    /**
     * Length of projectile's life in seconds
     * @type {number}
     */
    lifetime = 2;
    dead = false;
    speed = 100;
    velocity = this.speed;
    id = "";
    ownerid = "";

    constructor(scale = 1, materialColor, damage = 5, ownerid) {
        this.ownerid = ownerid;
        this.damage = damage;
        this.materialColor = materialColor;
        this.mesh = new THREE.Group();
        this.geometry = new THREE.SphereBufferGeometry(0.1 * scale);
        this.material = new THREE.MeshPhongMaterial({
            color: this.materialColor,
            emissive: this.materialColor,
            emissiveIntensity: 10
        });
        /* this.light = new THREE.PointLight(this.materialColor, 1, 10, 0.5);
        this.mesh.add(this.light); */
        this.body = new THREE.Mesh(this.geometry, this.material);
        this.mesh.add(this.body);
        let frame = new THREE.Mesh(new THREE.SphereBufferGeometry(0.3 * scale), new THREE.MeshBasicMaterial({
            wireframe: true,
            color: this.materialColor
        }));
        this.mesh.add(frame);
        this.id = Math.random().toString();
        this.speed *= scale;
        this.velocity = this.speed; //new THREE.Vector3(0, 0, -this.speed);
        game.totalProjectiles++;
    }

    /**
     * Functions
     */

    update(delta) {
        if (this.dead) return;
        /* this.checkCollision();
        this.move(delta); */

        this.lifetime -= delta;
        if (this.lifetime <= 0) {
            this.die();
        }
    }

    die() {
        if (!this.dead) game.totalProjectiles--;
        game.scene.remove(this.mesh);
        game.worker.postMessage({
            type: "killProjectile",
            id: this.id,
            ownerid: this.ownerid
        });
        this.dead = true;
    }

    move(delta) {
        //this.mesh.translateZ(-this.speed * delta);
    }

    checkCollision() {}
}
class SoundManager {
    sounds = [];

    constructor() {

    }

    loadSounds(list) {
        let s = [];
        for (let sound of list) {
            s.push(this.loadSound(sound));
        }
        return s;
    }

    /**
     * 
     * @param {string} url 
     */
    loadSound(url, volume = 0.2) {
        let sound = document.createElement('audio');
        sound.src = url;
        sound.volume = volume;
        let name = url;
        if (url.includes('/')) name = url.split('/')[1];
        name = name.split('.')[0];
        this.sounds[name] = sound;
        return sound;
    }
}
class Weapon {
    damage = 5;
    defaultAmmo = 100;
    defaultMagazine = 20;
    currentAmmo = 100;
    magazine = 20;
    autoFire = false;
    autoFireDelay = 0.1;
    autoFireCount = 0;
    soundDelay = 0.15;
    soundDelayCount = 0;
    pointer = null;
    /**
     * @type {Projectile[]}
     */
    projectiles = [];
    deadProjectiles = [];
    accuracy = 0.01;
    dead = false;
    reloading = false;
    reloadTime = 0.5;
    reloadTimeCounter = 0;
    defaultOptions = {
        scale: 1,
        ownerid: 0,
        projectileColor: 0x000000,
        weaponColor: 0xf0f0f0,
        accuracyMultiplier: 1,
        damage: 5
    }
    options = this.defaultOptions;

    /**
     * @type {Player}
     */
    owner = null;
    /**
     * @type {THREE.SpotLight}
     */
    dirLight = null;
    /**
     * 
     * @param {object} options 
     */
    constructor(options, owner) {
        for (let opt in options) {
            this.options[opt] = options[opt];
        }
        this.owner = owner;
        this.scale = this.options.scale;
        this.damage = this.options.damage;
        this.projectileColor = this.options.projectileColor;
        this.accuracy = this.accuracy * this.options.accuracyMultiplier;
        this.ownerid = this.options.ownerid;
        this.mesh = new THREE.Group();
        this.mesh.position.set(2, 0, 2);
        this.geometry = new THREE.BoxBufferGeometry(this.scale / 5, this.scale / 5, this.scale);
        this.mesh.castShadow = game.shadowsEnabled;

        this.body = new THREE.Mesh(this.geometry, new THREE.MeshPhongMaterial({
            color: 0x000000
        }));

        this.mesh.add(this.body);
        var material = new THREE.LineBasicMaterial({
            color: 0xff0000,
            transparent: true
        });

        var geo = new THREE.Geometry();
        geo.vertices.push(
            new THREE.Vector3(0, 0, 5 * this.scale),
            new THREE.Vector3(0, 0, 0)
        );

        this.pointer = new THREE.Line(geo, material);
        this.mesh.add(this.pointer);

        this.id = Math.random().toString();
    }

    update(delta) {

        if (this.reloading) {
            this.reloadTimeCounter += delta;
            if (this.reloadTimeCounter > this.reloadTime) {
                let bullets = this.defaultMagazine;
                bullets -= this.magazine;
                if (this.currentAmmo < bullets) {
                    bullets = this.currentAmmo;
                }
                this.magazine += bullets;
                this.currentAmmo -= bullets;
                this.mesh.rotateX(Math.PI / 4);
                this.pointer.material.opacity = 1;
                this.reloadTimeCounter = 0;
                this.reloading = false;

            }
        }
        this.soundDelayCount += delta;
        for (let projid in this.projectiles) {
            let projectile = this.projectiles[projid];
            projectile.update(delta);
            if (projectile.dead) {
                delete this.projectiles[projid];
            }
        }
        this.autoFireCount += delta;
        if (this.autoFire) this.fire();
    }

    reload() {
        if (!this.reloading && this.magazine < this.defaultMagazine && this.currentAmmo > 0) {
            this.reloading = true;
            this.mesh.rotateX(-Math.PI / 4);
            this.pointer.material.opacity = 0;
            this.owner.sm.sounds.reload.play();
        }
    }

    addFlashlight() {
        this.dirLight = new THREE.DirectionalLight(0xffffff, 1);
        this.dirLight.position.set(0, 1, 0);
        this.dirLight.castShadow = game.shadowsEnabled;
        this.dirLight.shadow.mapSize.width = game.shadowMapSize; // default is 512
        this.dirLight.shadow.mapSize.height = game.shadowMapSize; // default is 512
        //this.dirLight.rotateZ(Math.PI / 2);
        //this.dirLight.setRotationFromMatrix(this.mesh.matrix);
        //this.mesh.add(this.dirLight);
    }

    live() {
        this.dead = false;
    }

    die() {
        this.dead = true;
        this.autoFire = false;
        this.autoFireCount = 0;
        this.deleteAllProjectiles();
    }

    deleteAllProjectiles() {
        for (let projid in this.projectiles) {
            let projectile = this.projectiles[projid];
            projectile.die();
            game.scene.remove(projectile.mesh);
            delete this.projectiles[projid];
        }
    }

    fire() {
        if (this.dead || this.reloading) return false;
        if (this.autoFireCount < this.autoFireDelay) {

        } else {
            this.autoFireCount = 0;
            if (this.magazine == 0) {
                this.reload();
            } else {
                this.magazine--;
                this.createProjectile();
                if (this.soundDelayCount > this.soundDelay) {
                    this.soundDelayCount = 0;
                    this.owner.sm.sounds.laser.currentTime = 0;
                    this.owner.sm.sounds.laser.play();
                }
                if (this.magazine == 0)
                    this.reload();
            }
        }

    }

    createProjectile() {
        let projectile = new Projectile(this.scale, this.projectileColor, this.damage, this.ownerid);
        projectile.mesh.applyMatrix(this.mesh.matrixWorld);
        //projectile.mesh.setRotationFromEuler(this.mesh.rotation);
        projectile.mesh.rotateY(Math.PI);
        projectile.mesh.rotateX(randFloat(-this.accuracy, this.accuracy));
        projectile.mesh.rotateY(randFloat(-this.accuracy, this.accuracy));
        projectile.mesh.rotateZ(randFloat(-this.accuracy, this.accuracy));
        projectile.mesh.translateZ(-2);
        //this.newProjectile = projectile;
        this.projectiles[projectile.id] = projectile;
        game.scene.add(projectile.mesh);
        game.worker.postMessage({
            type: "projectile",
            id: projectile.id,
            ownerid: this.ownerid,
            position: game.vectorQuatToObject(projectile.mesh.position),
            quaternion: game.vectorQuatToObject(projectile.mesh.quaternion),
            velocity: projectile.velocity,
            damage: projectile.damage
        });
    }
}
/**
 * Definitions
 */

/**
 * @type {Game}
 */
let game;
let initInterval;

/**
 * Functions
 */

function init() {
    game = new Game();
    game.load();
    initInterval = setInterval(function () {
        if (game.playerModelLoaded && game.botModelLoaded && game.ammoModelLoaded && game.ammoModelLoaded) {
            game.ready = true;
            clearInterval(initInterval);
            game.init();
            addHandlers();

            game.start();
            run()
        }
    }, 500);
}

function run() {
    game.render();
    requestAnimationFrame(run);
    //setTimeout(run, 1000 / game.frameRate);
}

setTimeout(init, 0);
/* setTimeout(() => {
    window.location.reload()
}, 120000); */
function randFloat(min, max) {
    return Math.random() * (max - min) + min; //(Math.random() * max) + min;
}

function randFixed(min, max, digits) {
    return randFloat(min, max).toFixed(digits);
}

function randInt(min, max) {
    return Math.floor(randFloat(min, max));
}
function addHandlers() {
    document.onmousemove = function (e) {
        game.input.onmousemove(e);
    }

    document.onkeydown = function (e) {
        game.input.onkeydown(e);
    }
    document.onkeyup = function (e) {
        game.input.onkeyup(e);
    }

    document.onmousedown = function (e) {
        game.input.onmousedown(e);
    }

    document.onmouseup = function (e) {
        game.input.onmouseup(e);
    }

    document.oncontextmenu = function (e) {
        e.preventDefault();
        e.stopImmediatePropagation();
        e.stopPropagation();
        return false;
    }

    window.onresize = function () {
        game.resize();
    }

    game.renderer.domElement.requestPointerLock = game.renderer.domElement.requestPointerLock ||
        // @ts-ignore
        game.renderer.domElement.mozRequestPointerLock;

    document.exitPointerLock = document.exitPointerLock ||
        // @ts-ignore
        document.mozExitPointerLock;

    game.renderer.domElement.onclick = function () {
        game.renderer.domElement.requestPointerLock();
    };
}